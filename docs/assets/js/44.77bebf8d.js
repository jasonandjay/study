(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{215:function(t,e,s){"use strict";s.r(e);var n=s(0),a=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"小程序组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小程序组件","aria-hidden":"true"}},[t._v("#")]),t._v(" 小程序组件")]),t._v(" "),s("h5",{attrs:{id:"什么是组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是组件","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是组件")]),t._v(" "),s("blockquote",[s("p",[t._v("组件就是将一个功能进行封装，组件是视图层的基本组成单元，有自己独特的功能")])]),t._v(" "),s("h5",{attrs:{id:"组件的规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件的规范","aria-hidden":"true"}},[t._v("#")]),t._v(" 组件的规范")]),t._v(" "),s("ol",[s("li",[t._v("结构")]),t._v(" "),s("li",[t._v("样式")]),t._v(" "),s("li",[t._v("逻辑")]),t._v(" "),s("li",[t._v("通信方式")]),t._v(" "),s("li",[t._v("生命周期")]),t._v(" "),s("li",[t._v("可组合（可以嵌套）")]),t._v(" "),s("li",[t._v("定义组件")]),t._v(" "),s("li",[t._v("调用组件（标签的形式）")])]),t._v(" "),s("h5",{attrs:{id:"组件的创建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件的创建","aria-hidden":"true"}},[t._v("#")]),t._v(" 组件的创建")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.小程序中组件由4个文件组成，.json .wxmll .wxss .js\n2.创建组件实例需要通过Compoent(Object) 函数创建\n3.创建组件需要在组件的json文件中定义  component:true 字段指定为一个组件\n4.组件中的基础选项\n    (1)Properties: 接受的数据\n    (2)Data: 内部数据\n    (3)Methods: 处理函数\n5.使用组件\n6.需要在对应的页面或者组件的json文件中定义 usingComponents: {} 选项\n    usingComponets: {\n        '名-称': '组件路径'    \n    }\n7.在页面中可以实用  <名-称/>\n8.名称中不能出现大写字母，规则就是(字母_-)\n9.组件的组合可以实用slot插槽来完成，和vue一样，只不过没有作用域插槽， 可以有命名插槽和默认插槽\n10.组件的通信可以通过props传递参数(父子)， 自定义事件（子父）\n    (1)父子 <my-component test=”ssss” />\n    (2)子父 <my-component bindtest=”testFn” />  组件内部通过this.triggerEvent(‘test’, {detail:对象})\n")])])])])}],!1,null,null,null);e.default=a.exports}}]);