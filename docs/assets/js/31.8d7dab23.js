(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{147:function(t,a,e){"use strict";e.r(a);var i=e(0),s=Object(i.a)({},(function(){var t=this,a=t._self._c;return a("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),a("p",[t._v("webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。\nwebpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。")]),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),a("p",[t._v("在以上过程中，webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 webpack 提供的 API 改变 webpack 的运行结果。")]),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),a("p",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000018385415?utm_source=sf-related",target:"_blank",rel:"noopener noreferrer"}},[t._v("手动实现webpack"),a("OutboundLink")],1)]),t._v(" "),t._m(15),t._v(" "),t._m(16)])}),[function(){var t=this._self._c;return t("h1",{attrs:{id:"webpack篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack篇"}},[this._v("#")]),this._v(" Webpack篇")])},function(){var t=this._self._c;return t("h3",{attrs:{id:"webapck简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webapck简介"}},[this._v("#")]),this._v(" Webapck简介")])},function(){var t=this._self._c;return t("h3",{attrs:{id:"webpack常用配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack常用配置"}},[this._v("#")]),this._v(" Webpack常用配置")])},function(){var t=this,a=t._self._c;return a("ul",[a("li",[t._v("Entry：入口，webpack构建的起始")]),t._v(" "),a("li",[t._v("Output: 出口，webpack生成文件的一些配置")]),t._v(" "),a("li",[t._v("Module：模块，webpack里面一切皆模块，也是代表着文件，从Entry配置的入口文件开始，递归找出依赖的模块")]),t._v(" "),a("li",[t._v("Chunk：代码块，找出递归依赖模块经转换后组合成代码块")]),t._v(" "),a("li",[t._v("Loader：模块转换器，也就是将模块的内容按照需求装换成新内容")]),t._v(" "),a("li",[t._v("Plugin：扩展插件，webpack构建过程中，会在特定的时机广播对应的事件，而插件可以监听这些事件的发生")]),t._v(" "),a("li",[t._v("devServer: 本地服务配置")])])},function(){var t=this._self._c;return t("h3",{attrs:{id:"webpack的生命流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack的生命流程"}},[this._v("#")]),this._v(" Webpack的生命流程")])},function(){var t=this._self._c;return t("p",[t("img",{attrs:{src:"/study/book/webpack_lifecycle.jpeg",alt:"完整流程"}}),t("br"),this._v("\nwebpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：")])},function(){var t=this,a=t._self._c;return a("ul",[a("li",[t._v("初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；")]),t._v(" "),a("li",[t._v("开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；")]),t._v(" "),a("li",[t._v("确定入口：根据配置中的 entry 找出所有的入口文件")]),t._v(" "),a("li",[t._v("编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；")]),t._v(" "),a("li",[t._v("完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；")]),t._v(" "),a("li",[t._v("输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；")]),t._v(" "),a("li",[t._v("输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。")])])},function(){var t=this._self._c;return t("h3",{attrs:{id:"webpack如何打包优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack如何打包优化"}},[this._v("#")]),this._v(" webpack如何打包优化")])},function(){var t=this._self._c;return t("h4",{attrs:{id:"打包资源优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包资源优化"}},[this._v("#")]),this._v(" 打包资源优化")])},function(){var t=this._self._c;return t("ul",[t("li",[this._v("公用包的抽离，webpack3的CommonsChunkPlugin到webpack4的optimization.splitChunks 和 optimization.runtimeChunk")]),this._v(" "),t("li",[this._v("资源压缩optimize.UglifyJsPlugin 废弃，由 optimization.minimize 替代")])])},function(){var t=this._self._c;return t("h4",{attrs:{id:"打包优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包优化"}},[this._v("#")]),this._v(" 打包优化")])},function(){var t=this,a=t._self._c;return a("ul",[a("li",[t._v("缩小编译范围，减少不必要的编译工作，即 modules、mainFields、noParse、includes、exclude、alias等")]),t._v(" "),a("li",[t._v("通过 externals 配置来提取常用库，引用cdn")]),t._v(" "),a("li",[t._v("dllPlugin，动态链接第三方库")]),t._v(" "),a("li",[t._v("使用Happypack，将loader由单进程转为多进程")]),t._v(" "),a("li",[t._v("可视化打包，webpack-bundle-analyzer，各个模块的大小和依赖关系呈现出来")])])},function(){var t=this._self._c;return t("h3",{attrs:{id:"loader和plugin的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loader和plugin的区别"}},[this._v("#")]),this._v(" loader和plugin的区别")])},function(){var t=this._self._c;return t("ul",[t("li",[this._v("loader完成相应文件的转化处理（css-loader是否使用cssModule）")]),this._v(" "),t("li",[this._v("plugin通过注入的compiler监听整个构建过程中的事件，修改生成文件")]),this._v(" "),t("li")])},function(){var t=this._self._c;return t("h3",{attrs:{id:"webpack原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack原理"}},[this._v("#")]),this._v(" webpack原理")])},function(){var t=this._self._c;return t("h3",{attrs:{id:"runtime和manifest的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runtime和manifest的区别"}},[this._v("#")]),this._v(" runtime和manifest的区别")])},function(){var t=this._self._c;return t("ul",[t("li",[this._v("runtime就是调度更新，删除或修改文件的变化")]),this._v(" "),t("li",[this._v("manifest把打包后的文件和源文件做个映射")])])}],!1,null,null,null);a.default=s.exports}}]);